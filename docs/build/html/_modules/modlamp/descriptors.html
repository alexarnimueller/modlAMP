<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>modlamp.descriptors &mdash; modlAMP v2.6.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'v2.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/modlamp.ico"/>
    <link rel="top" title="modlAMP v2.6.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">modlAMP v2.6.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for modlamp.descriptors</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. currentmodule:: modlamp.descriptors</span>

<span class="sd">.. moduleauthor:: modlab Alex Mueller ETH Zurich &lt;alex.mueller@pharma.ethz.ch&gt;</span>

<span class="sd">This module incorporates different classes to calculate peptide descriptor values. The following classes are available:</span>

<span class="sd">=============================        ============================================================================</span>
<span class="sd">Class                                Characteristics</span>
<span class="sd">=============================        ============================================================================</span>
<span class="sd">:py:class:`GlobalDescriptor`         Global one-dimensional peptide descriptors calculated from the AA sequence.</span>
<span class="sd">:py:class:`PeptideDescriptor`        AA scale based global or convoluted descriptors (auto-/cross-correlated).</span>
<span class="sd">=============================        ============================================================================</span>

<span class="sd">.. seealso:: :class:`modlamp.core.BaseDescriptor` from which the classes in :mod:`modlamp.descriptors` inherit.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">join</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">sklearn.externals.joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="kn">from</span> <span class="nn">core</span> <span class="kn">import</span> <span class="n">BaseDescriptor</span><span class="p">,</span> <span class="n">load_scale</span><span class="p">,</span> <span class="n">count_aa</span><span class="p">,</span> <span class="n">aa_weights</span><span class="p">,</span> <span class="n">aa_energies</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Alex MÃ¼ller, Gisela Gabernet&quot;</span>
<span class="n">__docformat__</span> <span class="o">=</span> <span class="s">&quot;restructuredtext en&quot;</span>


<span class="k">def</span> <span class="nf">_one_autocorr</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private function used for calculating auto-correlated descriptors for 1 given sequence, window and an AA scale.</span>
<span class="sd">    This function is used by the :py:func:`calculate_autocorr` method of :py:class:`PeptideDescriptor`.</span>

<span class="sd">    :param seq: {str} amino acid sequence to calculate descriptor for</span>
<span class="sd">    :param window: {int} correlation-window size</span>
<span class="sd">    :param scale: {str} amino acid scale to be used to calculate descriptor</span>
<span class="sd">    :return: {numpy.array} calculated descriptor data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c"># list of lists to store translated sequence values</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c"># translate AA sequence into values</span>
        <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>
    <span class="c"># auto-correlation in defined sequence window</span>
    <span class="n">seqdesc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>  <span class="c"># for all correlation distances</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])):</span>  <span class="c"># for all features of the descriptor scale</span>
            <span class="n">valsum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">cntr</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c"># for every position in the sequence</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>  <span class="c"># check if corr distance is possible at that sequence position</span>
                    <span class="n">cntr</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># counter to scale sum</span>
                    <span class="n">valsum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">][</span><span class="n">val</span><span class="p">])</span>
            <span class="n">seqdesc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">valsum</span><span class="p">)</span> <span class="o">/</span> <span class="n">cntr</span><span class="p">)</span>  <span class="c"># append scaled correlation distance values</span>
    <span class="k">return</span> <span class="n">seqdesc</span>


<span class="k">def</span> <span class="nf">_one_crosscorr</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private function used for calculating cross-correlated descriptors for 1 given sequence, window and an AA scale.</span>
<span class="sd">    This function is used by the :py:func:`calculate_crosscorr` method of :py:class:`PeptideDescriptor`.</span>

<span class="sd">    :param seq: {str} amino acid sequence to calculate descriptor for</span>
<span class="sd">    :param window: {int} correlation-window size</span>
<span class="sd">    :param scale: {str} amino acid scale to be used to calculate descriptor</span>
<span class="sd">    :return: {numpy.array} calculated descriptor data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c"># list of lists to store translated sequence values</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c"># translate AA sequence into values</span>
        <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>
    <span class="c"># auto-correlation in defined sequence window</span>
    <span class="n">seqdesc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])):</span>  <span class="c"># for all features of the descriptor scale</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])):</span>  <span class="c"># for every feature cross correlation</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">cc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]):</span>  <span class="c"># check if corr distance is in range of the num of features</span>
                <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>  <span class="c"># for all correlation distances</span>
                    <span class="n">cntr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
                    <span class="n">valsum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c"># for every position in the sequence</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>  <span class="c"># check if corr distance is possible at that sequence pos</span>
                            <span class="n">cntr</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># counter to scale sum</span>
                            <span class="n">valsum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">][</span><span class="n">val</span> <span class="o">+</span> <span class="n">cc</span><span class="p">])</span>
                    <span class="n">seqdesc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">valsum</span><span class="p">)</span> <span class="o">/</span> <span class="n">cntr</span><span class="p">)</span>  <span class="c"># append scaled correlation distance values</span>
    <span class="k">return</span> <span class="n">seqdesc</span>


<span class="k">def</span> <span class="nf">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates charge of a single sequence. The method used is first described by Bjellqvist. In the case of</span>
<span class="sd">    amidation, the value for the  &#39;Cterm&#39; pKa is 15 (and Cterm is added to the pos_pks dictionary.</span>
<span class="sd">    The pKa scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th ed).</span>

<span class="sd">    **pos_pks** = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>

<span class="sd">    **neg_pks** = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">    :param ph: {float} pH at which to calculate peptide charge.</span>
<span class="sd">    :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">    :return: {array} descriptor values in the attribute :py:attr:`descriptor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">amide</span><span class="p">:</span>
        <span class="n">pos_pks</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Nterm&#39;</span><span class="p">:</span> <span class="mf">9.38</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">:</span> <span class="mf">10.67</span><span class="p">,</span> <span class="s">&#39;R&#39;</span><span class="p">:</span> <span class="mf">12.10</span><span class="p">,</span> <span class="s">&#39;H&#39;</span><span class="p">:</span> <span class="mf">6.04</span><span class="p">}</span>
        <span class="n">neg_pks</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Cterm&#39;</span><span class="p">:</span> <span class="mf">15.</span><span class="p">,</span> <span class="s">&#39;D&#39;</span><span class="p">:</span> <span class="mf">3.71</span><span class="p">,</span> <span class="s">&#39;E&#39;</span><span class="p">:</span> <span class="mf">4.15</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mf">8.14</span><span class="p">,</span> <span class="s">&#39;Y&#39;</span><span class="p">:</span> <span class="mf">10.10</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos_pks</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Nterm&#39;</span><span class="p">:</span> <span class="mf">9.38</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">:</span> <span class="mf">10.67</span><span class="p">,</span> <span class="s">&#39;R&#39;</span><span class="p">:</span> <span class="mf">12.10</span><span class="p">,</span> <span class="s">&#39;H&#39;</span><span class="p">:</span> <span class="mf">6.04</span><span class="p">}</span>
        <span class="n">neg_pks</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Cterm&#39;</span><span class="p">:</span> <span class="mf">2.15</span><span class="p">,</span> <span class="s">&#39;D&#39;</span><span class="p">:</span> <span class="mf">3.71</span><span class="p">,</span> <span class="s">&#39;E&#39;</span><span class="p">:</span> <span class="mf">4.15</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mf">8.14</span><span class="p">,</span> <span class="s">&#39;Y&#39;</span><span class="p">:</span> <span class="mf">10.10</span><span class="p">}</span>
    
    <span class="n">aa_content</span> <span class="o">=</span> <span class="n">count_aa</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="n">aa_content</span><span class="p">[</span><span class="s">&#39;Nterm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">aa_content</span><span class="p">[</span><span class="s">&#39;Cterm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">pos_charge</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">pK</span> <span class="ow">in</span> <span class="n">pos_pks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">c_r</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">pK</span> <span class="o">-</span> <span class="n">ph</span><span class="p">)</span>
        <span class="n">partial_charge</span> <span class="o">=</span> <span class="n">c_r</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_r</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">pos_charge</span> <span class="o">+=</span> <span class="n">aa_content</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">*</span> <span class="n">partial_charge</span>
    <span class="n">neg_charge</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">pK</span> <span class="ow">in</span> <span class="n">neg_pks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">c_r</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">ph</span> <span class="o">-</span> <span class="n">pK</span><span class="p">)</span>
        <span class="n">partial_charge</span> <span class="o">=</span> <span class="n">c_r</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_r</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">neg_charge</span> <span class="o">+=</span> <span class="n">aa_content</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">*</span> <span class="n">partial_charge</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">pos_charge</span> <span class="o">-</span> <span class="n">neg_charge</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<div class="viewcode-block" id="GlobalDescriptor"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor">[docs]</a><span class="k">class</span> <span class="nc">GlobalDescriptor</span><span class="p">(</span><span class="n">BaseDescriptor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for global, non-amino acid scale dependant descriptors. The following descriptors can be calculated by</span>
<span class="sd">    the **methods** linked below:</span>

<span class="sd">    - `Sequence Length      &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.length&gt;`_</span>
<span class="sd">    - `Molecular Weight     &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_MW&gt;`_</span>
<span class="sd">    - `Sequence Charge      &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_charge&gt;`_</span>
<span class="sd">    - `Charge Density       &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.charge_density&gt;`_</span>
<span class="sd">    - `Isoelectric Point    &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.isoelectric_point&gt;`_</span>
<span class="sd">    - `Instability Index    &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.instability_index&gt;`_</span>
<span class="sd">    - `Aromaticity          &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.aromaticity&gt;`_</span>
<span class="sd">    - `Aliphatic Index      &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.aliphatic_index&gt;`_</span>
<span class="sd">    - `Boman Index          &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.boman_index&gt;`_</span>
<span class="sd">    - `Hydrophobic Ratio    &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.hydrophobic_ratio&gt;`_</span>
<span class="sd">    - `all of the above     &lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_all&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GlobalDescriptor.length"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the length (total AA count) of every sequence in the attribute :py:attr:`sequences`.</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of sequence lengths in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor([&#39;AFDGHLKI&#39;,&#39;KKLQRSDLLRTK&#39;,&#39;KKLASCNNIPPR&#39;])</span>
<span class="sd">        &gt;&gt;&gt; desc.length()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 8], [12], [12]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;Length&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Length&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.calculate_MW"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_MW">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_MW</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to calculate the molecular weight [g/mol] of every sequence in the attribute :py:attr:`sequences`.</span>

<span class="sd">        :param amide: {boolean} whether the sequences are C-terminally amidated (subtracts 0.95 from the MW).</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;IAESFKGHIPL&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.calculate_MW(amide=True)</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 1210.43]])</span>

<span class="sd">        .. seealso:: :py:func:`modlamp.core.aa_weights()`</span>

<span class="sd">        .. versionchanged:: v2.1.5 amide option added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">aa_weights</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">mw</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>  <span class="c"># sum over aa weights</span>
                <span class="n">mw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">aa</span><span class="p">])</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mw</span><span class="p">)</span> <span class="o">-</span> <span class="mf">18.015</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>  <span class="c"># sum over AA MW and subtract H20 MW for every</span>
            <span class="c"># peptide bond</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">amide</span><span class="p">:</span>  <span class="c"># if sequences are amidated, subtract 0.98 from calculated MW</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="o">-</span> <span class="mf">0.98</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">desc</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;MW&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;MW&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.calculate_charge"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_charge">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ph</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to overall charge of every sequence in the attribute :py:attr:`sequences`.</span>

<span class="sd">        The method used is first described by Bjellqvist. In the case of amidation, the value for the &#39;Cterm&#39; pKa is 15</span>
<span class="sd">        (and Cterm is added to the pos_pKs dictionary.</span>
<span class="sd">        The pKa scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th ed).</span>

<span class="sd">        **pos_pKs** = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>

<span class="sd">        **neg_pKs** = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">        :param ph: {float} ph at which to calculate peptide charge.</span>
<span class="sd">        :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;KLAKFGKRSELVALSG&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.calculate_charge(ph=7.4, amide=True)</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 3.989]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;Charge&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Charge&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.charge_density"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.charge_density">[docs]</a>    <span class="k">def</span> <span class="nf">charge_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ph</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to calculate the charge density (charge / MW) of every sequences in the attributes :py:attr:`sequences`</span>

<span class="sd">        :param ph: {float} pH at which to calculate peptide charge.</span>
<span class="sd">        :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`.</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;GNSDLLIEQRTLLASDEF&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.charge_density(ph=6, amide=True)</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[-0.00097119]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_charge</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_MW</span><span class="p">(</span><span class="n">amide</span><span class="p">)</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">charges</span> <span class="o">/</span> <span class="n">masses</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;ChargeDensity&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;ChargeDensity&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.isoelectric_point"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.isoelectric_point">[docs]</a>    <span class="k">def</span> <span class="nf">isoelectric_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the isoelectric point of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        The pK scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th ed).</span>

<span class="sd">         **pos_pKs** = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>

<span class="sd">         **neg_pKs** = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">        :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;KLFDIKFGHIPQRST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.isoelectric_point()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 10.6796875]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>

            <span class="c"># Bracket between ph1 and ph2</span>
            <span class="n">ph</span> <span class="o">=</span> <span class="mf">7.0</span>
            <span class="n">charge</span> <span class="o">=</span> <span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">ph1</span> <span class="o">=</span> <span class="n">ph</span>
                <span class="n">charge1</span> <span class="o">=</span> <span class="n">charge</span>
                <span class="k">while</span> <span class="n">charge1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="n">ph1</span> <span class="o">+</span> <span class="mf">1.0</span>
                    <span class="n">charge</span> <span class="o">=</span> <span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">ph1</span> <span class="o">=</span> <span class="n">ph</span>
                        <span class="n">charge1</span> <span class="o">=</span> <span class="n">charge</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ph2</span> <span class="o">=</span> <span class="n">ph</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ph2</span> <span class="o">=</span> <span class="n">ph</span>
                <span class="n">charge2</span> <span class="o">=</span> <span class="n">charge</span>
                <span class="k">while</span> <span class="n">charge2</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="n">ph2</span> <span class="o">-</span> <span class="mf">1.0</span>
                    <span class="n">charge</span> <span class="o">=</span> <span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">charge</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">ph2</span> <span class="o">=</span> <span class="n">ph</span>
                        <span class="n">charge2</span> <span class="o">=</span> <span class="n">charge</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ph1</span> <span class="o">=</span> <span class="n">ph</span>
                        <span class="k">break</span>
            <span class="c"># Bisection</span>
            <span class="k">while</span> <span class="n">ph2</span> <span class="o">-</span> <span class="n">ph1</span> <span class="o">&gt;</span> <span class="mf">0.0001</span> <span class="ow">and</span> <span class="n">charge</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="n">ph1</span> <span class="o">+</span> <span class="n">ph2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">charge</span> <span class="o">=</span> <span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">ph1</span> <span class="o">=</span> <span class="n">ph</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ph2</span> <span class="o">=</span> <span class="n">ph</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;pI&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;pI&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.instability_index"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.instability_index">[docs]</a>    <span class="k">def</span> <span class="nf">instability_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the instability of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        The instability index is a prediction of protein stability based on the amino acid composition.</span>
<span class="sd">        ([1] K. Guruprasad, B. V Reddy, M. W. Pandit, Protein Eng. 1990, 4, 155â161.)</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;LLASMNDLLAKRST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.instability_index()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 63.95714286]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">module_path</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">)</span>
        <span class="n">dimv</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">module_path</span><span class="p">,</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="s">&#39;dimv.json&#39;</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">stabindex</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">stabindex</span> <span class="o">+=</span> <span class="n">dimv</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">10.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span> <span class="o">*</span> <span class="n">stabindex</span><span class="p">)</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;InstabilityInd&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;InstabilityInd&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.aromaticity"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.aromaticity">[docs]</a>    <span class="k">def</span> <span class="nf">aromaticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the aromaticity of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        According to Lobry, 1994, it is simply the relative frequency of Phe+Trp+Tyr.</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;GLFYWRFFLQRRFLYWW&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.aromaticity()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 0.52941176]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;W&#39;</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">)</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="n">w</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;Aromaticity&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Aromaticity&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.aliphatic_index"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.aliphatic_index">[docs]</a>    <span class="k">def</span> <span class="nf">aliphatic_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the aliphatic index of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        According to Ikai, 1980, the aliphatic index is a measure of thermal stability of proteins and is dependant</span>
<span class="sd">        on the relative volume occupied by aliphatic amino acids (A,I,L &amp; V).</span>
<span class="sd">        ([1] A. Ikai, J. Biochem. 1980, 88, 1895â1898.)</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;KWLKYLKKLAKLVK&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.aliphatic_index()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 139.28571429]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aa_dict</span> <span class="o">=</span> <span class="n">aa_weights</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">aa</span><span class="p">:</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">aa_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>  <span class="c"># count aa</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>  <span class="c"># get mole percent of all AA</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.9</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;V&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">3.9</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]))</span>  <span class="c"># formula for calculating the AI (Ikai, 1980)</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;AliphaticInd&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;AliphaticInd&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.boman_index"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.boman_index">[docs]</a>    <span class="k">def</span> <span class="nf">boman_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to calculate the boman index of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        According to Boman, 2003, the boman index is a measure for protein-protein interactions and is calculated by</span>
<span class="sd">        summing over all amino acid free energy of transfer [kcal/mol] between water and cyclohexane,[2] followed by</span>
<span class="sd">        dividing by    sequence length.</span>
<span class="sd">        ([1] H. G. Boman, D. Wade, I. a Boman, B. WÃ¥hlin, R. B. Merrifield, *FEBS Lett*. **1989**, *259*, 103â106.</span>
<span class="sd">        [2] A. Radzick, R. Wolfenden, *Biochemistry* **1988**, *27*, 1664â1670.)</span>
<span class="sd">        </span>
<span class="sd">        .. seealso:: :py:func:`modlamp.core.aa_energies()`</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;GLFDIVKKVVGALGSL&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.boman_index()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[-1.011875]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">aa_energies</span><span class="p">()</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
                <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;BomanInd&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;BomanInd&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.hydrophobic_ratio"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.hydrophobic_ratio">[docs]</a>    <span class="k">def</span> <span class="nf">hydrophobic_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the hydrophobic ratio of every sequence in the attribute :py:attr:`sequences`, which is the</span>
<span class="sd">        relative frequency of the amino acids **A,C,F,I,L,M &amp; V**.</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;VALLYWRTVLLAIII&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.hydrophobic_ratio()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 0.73333333]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aa_dict</span> <span class="o">=</span> <span class="n">aa_weights</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">pa</span> <span class="o">=</span> <span class="p">{</span><span class="n">aa</span><span class="p">:</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">aa_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>  <span class="c"># count aa</span>
            <span class="c"># formula for calculating the AI (Ikai, 1980):</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pa</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s">&#39;F&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s">&#39;M&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s">&#39;V&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;HydrophRatio&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;HydrophRatio&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.calculate_all"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_all">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ph</span><span class="o">=</span><span class="mf">7.4</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method combining all global descriptors and appending them into the feature matrix in the attribute</span>
<span class="sd">        :py:attr:`descriptor`.</span>
<span class="sd">        </span>
<span class="sd">        :param ph: {float} pH at which to calculate peptide charge</span>
<span class="sd">        :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; d = GlobalDescriptor(&#39;AFGHFKLKKLFIFGHERT&#39;)</span>
<span class="sd">        &gt;&gt;&gt; d.calculate_all(amide=true)</span>
<span class="sd">        &gt;&gt;&gt; d.featurenames</span>
<span class="sd">        [&#39;MW&#39;, &#39;ChargeDensity&#39;, &#39;pI&#39;, &#39;InstabilityInd&#39;, &#39;Aromaticity&#39;, &#39;AliphaticInd&#39;, &#39;BomanInd&#39;, &#39;HydrophRatio&#39;]</span>
<span class="sd">        &gt;&gt;&gt; d.descriptor</span>
<span class="sd">        array([[  2.17559000e+03,   1.87167619e-03,   1.16757812e+01, ...  1.10555556e+00,   4.44444444e-01]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>  <span class="c"># sequence length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_MW</span><span class="p">(</span><span class="n">amide</span><span class="o">=</span><span class="n">amide</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># molecular weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_charge</span><span class="p">(</span><span class="n">ph</span><span class="o">=</span><span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="n">amide</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># net charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_density</span><span class="p">(</span><span class="n">ph</span><span class="o">=</span><span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="n">amide</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># charge density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isoelectric_point</span><span class="p">(</span><span class="n">amide</span><span class="o">=</span><span class="n">amide</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># pI</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instability_index</span><span class="p">(</span><span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># instability index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aromaticity</span><span class="p">(</span><span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># global aromaticity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aliphatic_index</span><span class="p">(</span><span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># aliphatic index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boman_index</span><span class="p">(</span><span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># Boman index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hydrophobic_ratio</span><span class="p">(</span><span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># Hydrophobic ratio</span></div></div>


<div class="viewcode-block" id="PeptideDescriptor"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor">[docs]</a><span class="k">class</span> <span class="nc">PeptideDescriptor</span><span class="p">(</span><span class="n">BaseDescriptor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for peptide descriptors. The following **amino acid descriptor scales** are available for descriptor</span>
<span class="sd">    calculation:</span>

<span class="sd">    - **AASI**           (An amino acid selectivity index scale for helical antimicrobial peptides, *[1] D. JuretiÄ, D. VukiceviÄ, N. IliÄ, N. Antcheva, A. Tossi, J. Chem. Inf. Model. 2009, 49, 2873â2882.*)</span>
<span class="sd">    - **ABHPRK**          (modlabs inhouse physicochemical feature scale (Acidic, Basic, Hydrophobic, Polar, aRomatic, Kink-inducer)</span>
<span class="sd">    - **argos**          (Argos hydrophobicity amino acid scale, *[2] Argos, P., Rao, J. K. M. &amp; Hargrave, P. A., Eur. J. Biochem. 2005, 128, 565â575.*)</span>
<span class="sd">    - **bulkiness**      (Amino acid side chain bulkiness scale, *[3] J. M. Zimmerman, N. Eliezer, R. Simha, J. Theor. Biol. 1968, 21, 170â201.*)</span>
<span class="sd">    - **charge_physio**  (Amino acid charge at pH 7.0 - Hystidine charge +0.1.)</span>
<span class="sd">    - **charge_acidic**  (Amino acid charge at acidic pH - Hystidine charge +1.0.)</span>
<span class="sd">    - **cougar**         (modlabs inhouse selection of global peptide descriptors)</span>
<span class="sd">    - **eisenberg**      (the Eisenberg hydrophobicity consensus amino acid scale, *[4] D. Eisenberg, R. M. Weiss, T. C. Terwilliger, W. Wilcox, Faraday Symp. Chem. Soc. 1982, 17, 109.*)</span>
<span class="sd">    - **Ez**             (potential that assesses energies of insertion of amino acid side chains into lipid bilayers, *[5] A. Senes, D. C. Chadi, P. B. Law, R. F. S. Walters, V. Nanda, W. F. DeGrado, J. Mol. Biol. 2007, 366, 436â448.*)</span>
<span class="sd">    - **flexibility**    (amino acid side chain flexibilitiy scale, *[6] R. Bhaskaran, P. K. Ponnuswamy, Int. J. Pept. Protein Res. 1988, 32, 241â255.*)</span>
<span class="sd">    - **gravy**          (GRAVY hydrophobicity amino acid scale, *[7] J. Kyte, R. F. Doolittle, J. Mol. Biol. 1982, 157, 105â132.*)</span>
<span class="sd">    - **hopp-woods**     (Hopp-Woods amino acid hydrophobicity scale,*[8] T. P. Hopp, K. R. Woods, Proc. Natl. Acad. Sci. 1981, 78, 3824â3828.*)</span>
<span class="sd">    - **ISAECI**         (Isotropic Surface Area (ISA) and Electronic Charge Index (ECI) of amino acid side chains, *[9] E. R. Collantes, W. J. Dunn, J. Med. Chem. 1995, 38, 2705â2713.*)</span>
<span class="sd">    - **janin**          (Janin hydrophobicity amino acid scale, [10] J. L. Cornette, K. B. Cease, H. Margalit, J. L. Spouge, J. A. Berzofsky, C. DeLisi, J. Mol. Biol. 1987, 195, 659â685.*)</span>
<span class="sd">    - **kytedoolittle**  (Kyte &amp; Doolittle hydrophobicity amino acid scale, *[11] J. Kyte, R. F. Doolittle, J. Mol. Biol. 1982, 157, 105â132.*)</span>
<span class="sd">    - **levitt_alpha**   (Levitt amino acid alpha-helix propensity scale, extracted from http://web.expasy.org/protscale. *[12] M. Levitt, Biochemistry 1978, 17, 4277-4285.*)</span>
<span class="sd">    - **MSS**            (A graph-theoretical index that reflects topological shape and size of amino acid side chains, *[13] C. Raychaudhury, A. Banerjee, P. Bag, S. Roy, J. Chem. Inf. Comput. Sci. 1999, 39, 248â254.*)</span>
<span class="sd">    - **MSW**            (Amino acid scale based on a PCA of the molecular surface based WHIM descriptor (MS-WHIM), extended to natural amino acids, *[14] A. Zaliani, E. Gancia, J. Chem. Inf. Comput. Sci 1999, 39, 525â533.*)</span>
<span class="sd">    - **pepcats**        (modlabs pharmacophoric feature based PEPCATS scale, *[15] C. P. Koch, A. M. Perna, M. Pillong, N. K. Todoroff, P. Wrede, G. Folkers, J. A. Hiss, G. Schneider, PLoS Comput. Biol. 2013, 9, e1003088.*)</span>
<span class="sd">    - **polarity**       (Amino acid polarity scale, *[3] J. M. Zimmerman, N. Eliezer, R. Simha, J. Theor. Biol. 1968, 21, 170â201.*)</span>
<span class="sd">    - **PPCALI**         (modlabs inhouse scale derived from a PCA of 143 amino acid property scales, *[15] C. P. Koch, A. M. Perna, M. Pillong, N. K. Todoroff, P. Wrede, G. Folkers, J. A. Hiss, G. Schneider, PLoS Comput. Biol. 2013, 9, e1003088.*)</span>
<span class="sd">    - **refractivity**   (Relative amino acid refractivity values, *[16] T. L. McMeekin, M. Wilensky, M. L. Groves, Biochem. Biophys. Res. Commun. 1962, 7, 151â156.*)</span>
<span class="sd">    - **t_scale**        (A PCA derived scale based on amino acid side chain properties calculated with 6 different probes of the GRID program, *[17] M. Cocchi, E. Johansson, Quant. Struct. Act. Relationships 1993, 12, 1â8.*)</span>
<span class="sd">    - **TM_tend**        (Amino acid transmembrane propensity scale, extracted from http://web.expasy.org/protscale, *[18] Zhao, G., London E. Protein Sci. 2006, 15, 1987-2001.*)</span>
<span class="sd">    - **z3**             (The original three dimensional Z-scale, *[17] S. Hellberg, M. SjÃ¶strÃ¶m, B. Skagerberg, S. Wold, J. Med. Chem. 1987, 30, 1126â1135.*)</span>
<span class="sd">    - **z5**             (The extended five dimensional Z-scale, *[18] M. Sandberg, L. Eriksson, J. Jonsson, M. SjÃ¶strÃ¶m, S. Wold, J. Med. Chem. 1998, 41, 2481â2491.*)</span>

<span class="sd">    Further, amino acid scale independent methods can be calculated with help of the :class:`GlobalDescriptor` class.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PeptideDescriptor.__init__"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seqs</span><span class="p">,</span> <span class="n">scalename</span><span class="o">=</span><span class="s">&#39;Eisenberg&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param seqs: a .fasta file with sequences, a list of sequences or a single sequence as string to calculate the</span>
<span class="sd">            descriptor values for.</span>
<span class="sd">        :param scalename: {str} name of the amino acid scale (one of the given list above) used to calculate the</span>
<span class="sd">            descriptor values</span>
<span class="sd">        :return: initialized attributes :py:attr:`sequences`, :py:attr:`names` and dictionary :py:attr:`scale` with</span>
<span class="sd">            amino acid scale values of the scale name in :py:attr:`scalename`.</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;KLLKLLKKLLKLLK&#39;,&#39;pepcats&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.sequences</span>
<span class="sd">        [&#39;KLLKLLKKLLKLLK&#39;]</span>
<span class="sd">        &gt;&gt;&gt; seqs = PeptideDescriptor(&#39;/Path/to/file.fasta&#39;, &#39;eisenberg&#39;)  # load sequences from .fasta file</span>
<span class="sd">        &gt;&gt;&gt; seqs.sequences</span>
<span class="sd">        [&#39;AFDGHLKI&#39;,&#39;KKLQRSDLLRTK&#39;,&#39;KKLASCNNIPPR&#39;...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PeptideDescriptor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">load_scale</span><span class="p">(</span><span class="n">scalename</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c"># for passing hydrophobic moments to calculate_profile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c"># for passing global  to calculate_profile</span></div>

<div class="viewcode-block" id="PeptideDescriptor.load_scale"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.load_scale">[docs]</a>    <span class="k">def</span> <span class="nf">load_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to load amino acid values from a given scale</span>

<span class="sd">        :param scalename: {str} name of the amino acid scale to be loaded.</span>
<span class="sd">        :return: loaded amino acid scale values in a dictionary in the attribute :py:attr:`scale`.</span>

<span class="sd">        .. seealso:: :func:`modlamp.core.load_scale()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">load_scale</span><span class="p">(</span><span class="n">scalename</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_autocorr"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_autocorr">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_autocorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for auto-correlating the amino acid values for a given descriptor scale</span>

<span class="sd">        :param window: {int} correlation window for descriptor calculation in a sliding window approach</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: calculated descriptor numpy.array in the attribute :py:attr:`descriptor`.</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;PPCALI&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_autocorr(7)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[  1.28442339e+00,   1.29025116e+00,   1.03240901e+00, .... ]])</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor.shape</span>
<span class="sd">        (1, 133)</span>

<span class="sd">        .. versionchanged:: v.2.3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">_one_autocorr</span><span class="p">)(</span><span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_crosscorr"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_crosscorr">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_crosscorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for cross-correlating the amino acid values for a given descriptor scale</span>

<span class="sd">        :param window: {int} correlation window for descriptor calculation in a sliding window approach</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: calculated descriptor numpy.array in the attribute :py:attr:`descriptor`.</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;pepcats&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_crosscorr(7)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[ 0.6875    ,  0.46666667,  0.42857143,  0.61538462,  0.58333333, ... ]])</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor.shape</span>
<span class="sd">        (1, 147)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">_one_crosscorr</span><span class="p">)(</span><span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_moment"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_moment">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="s">&#39;max&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for calculating the maximum or mean moment of the amino acid values for a given descriptor scale and</span>
<span class="sd">        window.</span>

<span class="sd">        :param window: {int} amino acid window in which to calculate the moment. If the sequence is shorter than the</span>
<span class="sd">            window, the length of the sequence is taken. So if the default window of 1000 is chosen, for all sequences</span>
<span class="sd">            shorter than 1000, the **global** hydrophobic moment will be calculated. Otherwise, the maximal</span>
<span class="sd">            hydrophiobic moment for the chosen window size found in the sequence will be returned.</span>
<span class="sd">        :param angle: {int} angle in which to calculate the moment. **100** for alpha helices, **180** for beta sheets.</span>
<span class="sd">        :param modality: {&#39;max&#39; or &#39;mean&#39;} Calculate respectively maximum or mean hydrophobic moment.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: Calculated descriptor as a numpy.array in the attribute :py:attr:`descriptor` and all possible global</span>
<span class="sd">            values in :py:attr:`all_moms` (needed for the :py:func:`calculate_profile` method)</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;eisenberg&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_moment(window=1000, angle=100, modality=&#39;max&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[ 0.48790226]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s"> Descriptor moment calculation is only possible for one dimensional descriptors.</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
            <span class="n">wdw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>  <span class="c"># if sequence is shorter than window, take the whole sequence instead</span>
            <span class="n">mtrx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
                <span class="n">mtrx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>

            <span class="n">mwdw</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mtrx</span><span class="p">)</span> <span class="o">-</span> <span class="n">wdw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">mwdw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mtrx</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">wdw</span><span class="p">],</span> <span class="p">[]))</span>

            <span class="n">mwdw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mwdw</span><span class="p">)</span>
            <span class="n">rads</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">wdw</span><span class="p">))</span>  <span class="c"># calculate actual moment (radial)</span>
            <span class="n">vcos</span> <span class="o">=</span> <span class="p">(</span><span class="n">mwdw</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rads</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">vsin</span> <span class="o">=</span> <span class="p">(</span><span class="n">mwdw</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rads</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">moms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vsin</span> <span class="o">*</span> <span class="n">vsin</span> <span class="o">+</span> <span class="n">vcos</span> <span class="o">*</span> <span class="n">vcos</span><span class="p">)</span> <span class="o">/</span> <span class="n">wdw</span>

            <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s">&#39;max&#39;</span><span class="p">:</span>  <span class="c"># take window with maximal value</span>
                <span class="n">moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">modality</span> <span class="o">==</span> <span class="s">&#39;mean&#39;</span><span class="p">:</span>  <span class="c"># take average value over all windows</span>
                <span class="n">moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Modality parameter is wrong, please choose between &quot;max&quot; and &quot;mean&quot;.</span><span class="se">\n</span><span class="s">&#39;</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moment</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_global"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_global">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_global</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="s">&#39;max&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for calculating a global / window averaging descriptor value of a given AA scale</span>

<span class="sd">        :param window: {int} amino acid window in which to calculate the moment. If the sequence is shorter than the</span>
<span class="sd">            window, the length of the sequence is taken.</span>
<span class="sd">        :param modality: {&#39;max&#39; or &#39;mean&#39;} Calculate respectively maximum or mean hydrophobic moment.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: Calculated descriptor as a numpy.array in the attribute :py:attr:`descriptor` and all possible global</span>
<span class="sd">            values in :py:attr:`all_globs` (needed for the :py:func:`calculate_profile` method)</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;eisenberg&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_global(window=1000, modality=&#39;max&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[ 0.44875]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
            <span class="n">wdw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
            <span class="n">mtrx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c"># translate AA sequence into values</span>
                <span class="n">mtrx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>
            <span class="n">mwdw</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mtrx</span><span class="p">)</span> <span class="o">-</span> <span class="n">wdw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">mwdw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mtrx</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">wdw</span><span class="p">],</span> <span class="p">[]))</span>  <span class="c"># list of all the values for the different windows</span>
            <span class="n">mwdw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mwdw</span><span class="p">)</span>
            <span class="n">glob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mwdw</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">wdw</span>
            <span class="k">if</span> <span class="n">modality</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;max&#39;</span><span class="p">,</span> <span class="s">&#39;mean&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s">&#39;max&#39;</span><span class="p">:</span>
                    <span class="n">outglob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>  <span class="c"># returned moment will be the maximum of all windows</span>
                <span class="k">elif</span> <span class="n">modality</span> <span class="o">==</span> <span class="s">&#39;mean&#39;</span><span class="p">:</span>
                    <span class="n">outglob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>  <span class="c"># returned moment will be the mean of all windows</span>
                <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outglob</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;Modality parameter is wrong, please choose between &quot;max&quot; and &quot;mean&quot;</span><span class="se">\n</span><span class="s">.&#39;</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_profile"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_profile">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof_type</span><span class="o">=</span><span class="s">&#39;uH&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for calculating hydrophobicity or hydrophobic moment profiles for given sequences and fitting for</span>
<span class="sd">        slope and intercept. The hydrophobicity scale used is &quot;eisenberg&quot;</span>

<span class="sd">        :param prof_type: prof_type of profile, available: &#39;H&#39; for hydrophobicity or &#39;uH&#39; for hydrophobic moment</span>
<span class="sd">        :param window: {int} size of sliding window used (odd-numbered).</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: Fitted slope and intercept of calculated profile for every given sequence in the attribute</span>
<span class="sd">            :py:attr:`descriptor`.</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;KLLKLLKKVVGALG&#39;,&#39;kytedoolittle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_profile(prof_type=&#39;H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[ 0.03731293,  0.19246599]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prof_type</span> <span class="o">==</span> <span class="s">&#39;uH&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_moment</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
            <span class="n">y_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span>
        <span class="k">elif</span> <span class="n">prof_type</span> <span class="o">==</span> <span class="s">&#39;H&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_global</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
            <span class="n">y_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;prof_type parameter is unknown, choose &quot;uH&quot; for hydrophobic moment or &quot;H&quot; for hydrophobicity</span><span class="se">\n</span><span class="s">.&#39;</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
            <span class="n">x_vals</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))[((</span><span class="n">window</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span><span class="o">-</span><span class="p">((</span><span class="n">window</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">:</span>
                <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/modlab.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">modlAMP v2.6.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, modlab ETH Zurich, Alex Mueller.
      Last updated on Nov 28, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>